2017/04/24
葛尧：
    新建了三个基础的类
    测试了一下，在没有任何输出的情况下，使用strategy = GenerationType.IDENTITY策略，插入1000条数据大概需要2.5~3秒。
    插入10000条需要16.5秒
    一万条数据的情况下，查找一条数据，重复1000次，需要2秒多
    调整了一下目录结构。pojo下面根据不同的安全级别来划分。

    测试了一下视图，hibernate就算在root账户下，都不能直接对视图的行列进行增加，别的可以像使用普通表一样使用视图。
    开启了注解式计划方法

2017/04/25
葛尧：
    测试了腾讯云的上传下载功能

2017/04/26
葛尧：
    设计加密与缓存机制。
    缓存机制，接口Cache，目前有5个方法，把缓存当做是Map一样操作。实现类是 LocalCache，里面有一个map来存放缓存。
    缓存的结构是String - Map .后者是类似于Session的结构，也会用作别的东西，如加密机制。详细参考——
    foolkey/pojo/root/CAO/缓存说明.txt

    加密机制分为RSA非对称加密和AES对称加密机制，后者是主要使用的，因为它快，但密钥要传给app端，则必须用非对称加密传过去
    由App端保存。机制如下：
    第一次使用，即注册时：
    app向server提交 ：服务器公钥 请求
    server返回值    ：服务器公钥，明文传输，用于app加密

    app向server提交 ：服务器公钥加密后的 userName passWord，AESKey，密文,base64格式
    server返回值    ：注册结果, token, AESKey加密的密文

    之后使用AES加密来传输，三段，1：明文，一定要包含，token
                             2：密文，要包含 token(AES密钥加密)
                             3：密文的其他信息（AES密钥加密）
                             服务器会根据1，找到对应的AES密钥加密，然后对2进行解谜，看是否和1相等，如果相等，则继续看第三部分，是否能揭秘正常。


//    退出登录后，重新登录：
//    app向server提交 ：服务器公钥 请求
//    server返回值    ：服务器公钥，明文传输，用于app公钥加密

//    app向server提交 ：用户名密码，以及AES密钥，用server端公钥加密传输
//    server返回值    ：登录结果、用户新token，用AES密钥，加密

    服务器的公私钥 和 app的公钥 会被持久化，AES不会被持久化

    写了一个拦截器，拦截 /rsa/*后面的请求，将会用服务器的私钥进行解谜，揭秘失败则返回false

2017/04/27
葛尧：
    和前端通了一下密码学，不太成功。
    解决了RSA非对称加密的问题，Java和安卓端使用的JVM不同，所以实现加密的方式也不同，需要服务器端为其做出修改
    Cipher类的getInstence方法要传入"RSA/None/Padding"

2017/04/28
葛尧：
    注册时，前端给我的JSON，分为三个字段：userName，passWord，AESKey，我返回token
    完成了注册、更新用户密钥的controller编写，制定以下的依赖层次，不可跨层依赖
    controller
    bo ：事务加在这一层
    dao / cao
    hibernate / cache

    约定 使用AOP、或者来完成加解密的工作，同时把密码的 SHA1加密工作移交给 APP。
        我也写了对于密码进行 SHA1加密的AOP foolkey.aop.passWordEncrypt.PassWordSHA1EncryptAOP
        对于RSA算法的解密，写了一个通用的解密拦截器，等待测试：foolkey.interceptor.com.RSADecryptInterceptor
    对于RSA加密的信息，实际上是一个结构简单的JSON
        key - 明文
        value - 密文，且为简单String格式，即不为JSON

    写了一个全局异常处理器 foolkey.controller.exceptionHandler.GlobalExceptionHandler，会打印异常，抛出result:fail


2017/05/01
葛尧：
    在缓存中增加了2个区，id——token互为键值对的2个map
    新写了一个方法，TokenCreator，用来生成token，目前是简单的相加
    UserCAO里增加了保存id——token键值对到缓存的方法
    在CourseTeacherBO里写了一个方法，用来验证一个老师课程是否可以被购买
    新建 对老师课程的申请
    现在只有付款以后，才会生成消息与申请，并发送给老师。
    Application将不包含courseId，而包含orderId了

    使用优惠券的deadTime判断此优惠券是否使用或过期

    付款的controller，以及加强了对优惠券的验证

    关于优惠券的使用：付款时，记录时间为优惠券的deadTime，教完以后，优惠券从数据库删除。

    自己写了一个字符串匹配率的函数，只要匹配率大于80%，就认为是相等的

    现在有关更新缓存的代码，有很多冗余

    现在根据id获取学生，必须从数据库取了


     * 如果学生用户试图发布课程，或者主动点击【我的-切换教师-申请认证】，就会提示他需要认证, role会变成 alreadyApplied
     * 需要去完成来自【5】个【不同学生】的悬赏【任务】
     * 且中间不能有【3星】以下的评分，如果有，则认证失败, verified变成refused,
     * 如果一路高分评价，则顺利成为老师，他的verifyState 字段，将会变成verified， role会变成 teacher
     * 可以正常进行 发布课程、接受提问、发表文章的功能。