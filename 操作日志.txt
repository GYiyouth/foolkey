2017/04/24
葛尧：
    新建了三个基础的类
    测试了一下，在没有任何输出的情况下，使用strategy = GenerationType.IDENTITY策略，插入1000条数据大概需要2.5~3秒。
    插入10000条需要16.5秒
    一万条数据的情况下，查找一条数据，重复1000次，需要2秒多
    调整了一下目录结构。pojo下面根据不同的安全级别来划分。

    测试了一下视图，hibernate就算在root账户下，都不能直接对视图的行列进行增加，别的可以像使用普通表一样使用视图。
    开启了注解式计划方法

2017/04/25
葛尧：
    测试了腾讯云的上传下载功能

2017/04/26
葛尧：
    设计加密与缓存机制。
    缓存机制，接口Cache，目前有5个方法，把缓存当做是Map一样操作。实现类是 LocalCache，里面有一个map来存放缓存。
    缓存的结构是String - Map .后者是类似于Session的结构，也会用作别的东西，如加密机制。详细参考——
    foolkey/pojo/root/CAO/缓存说明.txt

    加密机制分为RSA非对称加密和AES对称加密机制，后者是主要使用的，因为它快，但密钥要传给app端，则必须用非对称加密传过去
    由App端保存。机制如下：
    第一次使用，即注册时：
    app向server提交 ：服务器公钥 请求
    server返回值    ：服务器公钥，明文传输，用于app加密

    app向server提交 ：服务器公钥加密后的 userName passWord，AESKey，密文,base64格式
    server返回值    ：注册结果, token, AESKey加密的密文

    之后使用AES加密来传输，三段，1：明文，一定要包含，token
                             2：密文，要包含 token(AES密钥加密)
                             3：密文的其他信息（AES密钥加密）
                             服务器会根据1，找到对应的AES密钥加密，然后对2进行解谜，看是否和1相等，如果相等，则继续看第三部分，是否能揭秘正常。


//    退出登录后，重新登录：
//    app向server提交 ：服务器公钥 请求
//    server返回值    ：服务器公钥，明文传输，用于app公钥加密

//    app向server提交 ：用户名密码，以及AES密钥，用server端公钥加密传输
//    server返回值    ：登录结果、用户新token，用AES密钥，加密

    服务器的公私钥 和 app的公钥 会被持久化，AES不会被持久化

    写了一个拦截器，拦截 /rsa/*后面的请求，将会用服务器的私钥进行解谜，揭秘失败则返回false

2017/04/27
葛尧：
    和前端通了一下密码学，不太成功。
    解决了RSA非对称加密的问题，Java和安卓端使用的JVM不同，所以实现加密的方式也不同，需要服务器端为其做出修改
    Cipher类的getInstence方法要传入"RSA/None/Padding"